■プログラムメモ

・TFDを用いてUpdateリフレクションやDeleteリフレクションをするとき、TFDとDDT番号だけ指定するというのが現時点の仕様。
　RelatedRecordFinderにTFDとDDT番号を渡しgetRecordLocations()を実行すれば、
　DDTの中から、TFDに対応する全レコードのレコードロケーションを返してくれる。
　そのレコード達にUpdateやDeleteをするわけである。
　現在、そのレコード達の数はTFDのレコード数に一致することを前提としている。
　もちろんそうならないことも考えられるのだが、その場合はかなり厄介であろう。
　RelatedRecordFinder::getRecordLocations()中でそうなった場合、現時点ではエラーを出力している。

・CreateフォームにFILE型が存在する場合、Createフォームからのリクエストに基づいて作られたTFDの中では、
　そのFILE型フィールドの値はFileValueインスタンスであるが、そのインスタンス変数であるCellLocationインスタンスはnullとしている。
　（これから作られようとしているセルのセルロケーションなどまだわからないため）

・PASSWORD型のフィールドに対してはRead権限を設定することはできない。
　読出しのときには問答無用で"　"（全角スペース１つ）を表示する。（全セル空欄のレコードの条件に会わせたいため）

・データタイプに関わる変更は、次の全ての場所に反映すること
	・DataTypeクラス
		・定数
		・__construct()
	・FieldInformationクラス
		・__construct()
	・DdtTfdConverterクラス
		convDdtToTfd()
	・UpdateReflectionExecuterクラス
		convUpdFormToTfd()
	・UpdateFormGeneratorクラス
		generateCellHtml()

・ROLE_NAME型フィールドはDDFとして扱うものとする
	・READができるか否かは権限で設定できる
	・Updateは決してできない

・TFDへRDFを記録するか否か
	・現時点で、必要ないと判断する。つまりTFDにはUser Friendly Fieldのみを記録する（決定事項）。理由は次の通り。
		・RDFというのは今のところレコードの主キーを記録するフィールドのみである。
		　DDTをTFDに変換するときにレコードの主キーをTFDに書き残したって意味はない。
		　TFD中のあるセルに着目したとき、そのセルのセルヒストリーを見れば、そのセルがDDT中のどのセルに対応しているかがわかり、
		　すなわちDDT中のどのレコードに対応しているかもわかるからである。
	

・UpdateReflectionExecuterクラス
	・インスタンス化した直後、addOffsetRelation()の実行が必要なので注意
	・convUpdFormToTfd()
		・この関数ではUpdateフォームからの全リクエストを調べTFDに変換するが、
		　このTFDの行数とフィールド数は、DDTのそれと一致する。
		　つまりUpdateフォームで例えばフィールド「学籍番号」がフィールド限定で排除されていても、
		　TFDには「学籍番号」に対応した列があり、その列の全セルの値にはNoUpdateインスタンスが格納される。（NoUpdateインスタンスは「更新しない」ことを表す）
		　同じく、Updateフォームに表示されていない（そもそも更新ができない）レコードがあるケースもあるだろうが、
		　それらのレコードに対応した行がTFDにはあり、レコード中の全セルの値としてNoUpdateインスタンスが格納される。


・Create, Update の標準フォームのactionの問題
	・下に２つの手段が書いてあるが、前者は異常に面倒そうなので後者にする（決定事項！）
	　セッション情報を駆使することで自然な実装が可能となるだろう
	・actionを、標準フォームが置かれているページ自身とした場合を考える。
	　つまり、標準フォームの値を受け取りCreate, Updateを行うという処理は、そのページ自身のPHPファイルで行うことになる
	　この場合のデメリットは次の通り
		・このページのPHPファイルでCreateやUpdateが完了後、続けて様々なTPPを実行したい場合もある。
		　遷移先で「標準フォームを用いたCreateやUpdateなどの処理は既に完了している」という前提でそれ以外のTPPを実行する。
		　この時点でなんだか気持ち悪い。
		・そしてそれらのTPPの実行に失敗して前ページに戻るというケースが考えられるが、そのとき、CreateやUpdateを取り消さねばならない。
		　これは非常に面倒な実装になるだろう
			・トランザクションのロールバックを行えばいいのでは？
				-> ダメ。
				トランザクションを利用するなら、まずフォームデータが遷移元に送られ、遷移元のPHPファイルでトランザクションがスタート、CreateやUpdateをする。
				しかしその後遷移先へ移るので、Mysqlコネクションは切断されることになる。（ここで勝手にロールバックされる）
				遷移先のPHPファイルでは別のコネクションが開かれるが、このコネクションの中でコミットやロールバックを行っても無意味。
	・actionを、遷移先ページとした場合を考える。次のようなデメリットがある
		・submitボタンを押してCreate, Update を行おうとした瞬間、当然入力値のチェックを行う。
		　0~100の値が入るべきセルに200が入力されていれば、「値が不正です」などの警告メッセージが添えられた状態で再びフォームを表示したい。
		　フォームには入力してあった値が再表示される。
		　遷移先ページにフォームデータを送るようにしていると、遷移先ページのPHPファイルでそれを受け取り入力チェックを行う。
		　そして不正な値を見つけた場合、入力してあった値をすべて遷移元に渡さなければならない。
		　GETはなんだか嫌だし、POSTの場合「とっさにフォームを作ってJavaScriptでsubmitボタンを押す」という気持ちの悪い仕様になる。

・ログイン成功時にはheader()でヘッダを出力しジャンプするが、
　デバッグモードだとヘッダより先にデバッグ文字列が出力されるのでエラーになる。
　デバッグモードをオフにすること

・PageHtmlGenerator generate()
　最後の行で、ログイン成功時の遷移先ページのファイル名$destPageFileNameをそのままauthenticateIfTried()へ渡しているが、
　「Webページ本体上でauthenticateIfTried()を呼び出す（requireの関係でそうなる）のだから$destPageFileNameの先頭にどんなパスもいらないだろう」
　と仮定している。

・TPP一覧
	・Create Form Reflection ... 標準Create Formの値を受け取りリフレクション
	・Update Form Reflection ... 標準Update Formの値を受け取りリフレクション
	・Delete Form Reflection ... 標準Delete Formの値を受け取りリフレクション
	・サービス実行（値はTPP結果バッファに格納）
	・DDT読み出し（DDT全体をTFDに変換し、TPP結果バッファに格納）

・HTMLの出力
	・HTMLタグの後などに\nをつけたい場合、''ではなく""で囲わないとならないようである
		・""で囲うと、ちゃんとWebページ上で改行されている
		・''で囲うと、Webページに「￥n」と表示されてしまう（￥は実際は半角）

・TfdHtmlCreatorクラス
	・インスタンス変数 $authReflect は、Table Displayの出力ではtrue、Display Areaの出力ではfalseにする


・AuthoritySetインスタンスのインスタンス変数の値は、0か1が格納される（true or false ではないので注意）




File型のセルの値は、TFDではFileValueインスタンスとして格納する
	・FileValueインスタンスの中身
		・ファイル名
		・セルロケーション



RWE
000		完全な空白
001		ロックだけ
010		空欄の書換フォーム
011		空欄の書換フォーム、ロックはしてもしなくてもよい
100		現在値だけ
101		現在値の入った書換フォーム、「書き換える（ロックされます）」のチェックボックス（これがチェックされていないと、値が変わっていても更新はされない）
110		現在値の入った書換フォーム
111		現在値の入った書換フォーム、ロックはしてもしなくてもよい



◆ExWriteは「書き換えて同時にロックする」ことを指す
Writeを書換権限、ExWriteをロック権限とした場合→ダメ
輪講室予約システムの、「書換えるときは必ずロックさせる」という仕様が不可能
Write	ExWrite
0		0		×
0		1		×
1		0		ロックできない
1		1		書換えてロックしない、ということができてしまう